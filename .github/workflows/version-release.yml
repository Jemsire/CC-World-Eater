name: Auto Version Release

on:
  push:
    branches:
      - main
      - master
    paths:
      - "hub_files/version.lua"
  workflow_dispatch:

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh

      - name: Parse version.lua
        id: version
        run: |
          VF="shared_files/version.lua"

          MAJOR=$(grep -v '^\s*--' "$VF" | grep -E 'major\s*=' | sed -E 's/.*major[[:space:]]*=[[:space:]]*([0-9]+).*/\1/')
          MINOR=$(grep -v '^\s*--' "$VF" | grep -E 'minor\s*=' | sed -E 's/.*minor[[:space:]]*=[[:space:]]*([0-9]+).*/\1/')
          HOTFIX=$(grep -v '^\s*--' "$VF" | grep -E 'hotfix\s*=' | sed -E 's/.*hotfix[[:space:]]*=[[:space:]]*([0-9]+).*/\1/')

          VERSION="${MAJOR}.${MINOR}.${HOTFIX}"
          TAG="v${VERSION}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "Parsed version: ${VERSION}, tag: ${TAG}"

      - name: Determine previous tag
        id: prev
        run: |
          PREV=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "previous=${PREV}" >> $GITHUB_OUTPUT
          echo "Previous tag: $PREV"

      - name: Generate changelog
        run: |
          OLD_TAG="${{ steps.prev.outputs.previous }}"

          if [ -z "$OLD_TAG" ]; then
            git log --pretty=format:"- %s (%h) — by %an" > CHANGELOG.md
          else
            git log "$OLD_TAG"..HEAD --pretty=format:"- %s (%h) — by %an" > CHANGELOG.md
          fi

      - name: Create or Update Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          echo "Creating release with TAG=$TAG, VERSION=$VERSION"

          # Read changelog, handle empty file
          if [ -f CHANGELOG.md ] && [ -s CHANGELOG.md ]; then
            CHANGELOG_CONTENT=$(cat CHANGELOG.md)
          else
            CHANGELOG_CONTENT="No changes recorded."
          fi

          # Write notes to a temp file to avoid shell escaping issues
          NOTES_FILE=$(mktemp)
          {
            echo "### Version ${VERSION}"
            echo ""
            echo "#### Changes"
            echo "${CHANGELOG_CONTENT}"
            echo ""
            echo "---"
            echo "*Automatically generated from commit history.*"
          } > "$NOTES_FILE"

          echo "Checking if release exists..."
          set +e
          RELEASE_ID=$(gh api repos/${{ github.repository }}/releases/tags/${TAG} --jq '.id' 2>/dev/null)
          RELEASE_CHECK_EXIT=$?
          set -e

          if [ $RELEASE_CHECK_EXIT -ne 0 ] || [ -z "$RELEASE_ID" ]; then
            echo "Creating new release: $TAG"
            gh release create "$TAG" \
              --title "v${VERSION}" \
              --notes-file "$NOTES_FILE" \
              --latest
          else
            echo "Updating existing release: $TAG (ID: $RELEASE_ID)"
            gh release edit "$TAG" \
              --title "v${VERSION}" \
              --notes-file "$NOTES_FILE" \
              --latest
          fi
          
          rm -f "$NOTES_FILE"
          echo "Release created/updated successfully!"
