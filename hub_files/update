-- WORLD EATER: Hub Update Script
-- Downloads files from GitHub and updates the hub system
-- Usage: update [force-config]
--   force-config: If provided, will also update config files

local GITHUB_REPO = "Jemsire/CC-World-Eater"
local GITHUB_BRANCH = "main"
local GITHUB_BASE = "https://raw.githubusercontent.com/" .. GITHUB_REPO .. "/" .. GITHUB_BRANCH

-- Check for force-config argument
local force_config = false
if arg and arg[1] == "force-config" then
    force_config = true
    print("Force update mode: Config files will be updated")
end

-- Files to exclude from update (unless force-config is set)
local config_files = {
    ["hub_files/config.lua"] = true,
    ["turtle_files/config.lua"] = true,
    ["pocket_files/info.lua"] = true,  -- Pocket config file
}

-- Determine drive path first (needed for helper loading)
local drive_path = "/disk"
if not fs.exists(drive_path) then
    error("No disk drive found!")
end

-- Load GitHub API helper (if available)
local github_api = nil
local helper_paths = {
    "/disk/hub_files/github_api.lua",
    drive_path .. "/hub_files/github_api.lua",
    "/hub_files/github_api.lua"
}

for _, path in ipairs(helper_paths) do
    if fs.exists(path) then
        local helper_func = loadfile(path)
        if helper_func then
            github_api = helper_func()
            break
        end
    end
end

-- If helper not found, define functions inline (fallback)
if not github_api then
    github_api = {}
    
    function github_api.parse_json_simple(json_str)
        local tree_array = string.match(json_str, '"tree"%s*:%s*%[%s*(.*)%s*%]')
        if not tree_array then return nil end
        local filtered = {}
        for obj_match in string.gmatch(tree_array, '{[^}]+}') do
            local path = string.match(obj_match, '"path"%s*:%s*"([^"]+)"')
            local obj_type = string.match(obj_match, '"type"%s*:%s*"([^"]+)"')
            if path and obj_type == "file" then
                table.insert(filtered, path)
            end
        end
        return filtered
    end
    
    function github_api.get_file_tree(github_repo, github_branch)
        local api_url = "https://api.github.com/repos/" .. github_repo .. "/git/trees/" .. github_branch .. "?recursive=1"
        local response = http.get(api_url, {["Accept"] = "application/vnd.github.v3+json"})
        if not response then return nil end
        
        local content = response.readAll()
        response.close()
        
        local json_data = nil
        if textutils and textutils.unserializeJSON then
            json_data = textutils.unserializeJSON(content)
        else
            local file_paths = github_api.parse_json_simple(content)
            if file_paths then
                json_data = {tree = {}}
                for _, path in ipairs(file_paths) do
                    table.insert(json_data.tree, {path = path, type = "file"})
                end
            end
        end
        
        return json_data and json_data.tree or nil
    end
end

-- Download file list from GitHub using API (dynamic discovery)
local function get_hub_files()
    local tree = github_api.get_file_tree(GITHUB_REPO, GITHUB_BRANCH)
    
    if not tree then
        error("Failed to retrieve file list from GitHub API. Please check your internet connection and try again.")
    end
    
    -- Collect hub files
    local hub_files = {}
    for _, item in ipairs(tree) do
        if item.type == "file" and item.path then
            local path = item.path
            -- Include hub_files/* and hub.lua, exclude config unless force_config
            if string.match(path, "^hub_files/") then
                -- Skip config file unless force_config is enabled
                if not config_files[path] or force_config then
                    table.insert(hub_files, path)
                end
            elseif path == "hub.lua" then
                table.insert(hub_files, path)
            end
        end
    end
    
    return hub_files
end

-- Get hub files dynamically from GitHub
local hub_files = get_hub_files()

-- Check for HTTP API
if not http then
    error("HTTP API not available! Cannot download updates.")
end

print("========================================")
print("  World Eater Hub Update")
print("========================================")

-- Function to format version table as string "MAJOR.MINOR.HOTFIX"
local function format_version(version)
    if version and type(version) == "table" then
        return string.format("%d.%d.%d", version.major or 0, version.minor or 0, version.hotfix or 0)
    end
    return nil
end

-- Function to compare two semantic versions
-- Returns: -1 if v1 < v2, 0 if v1 == v2, 1 if v1 > v2
local function compare_versions(v1, v2)
    if not v1 or not v2 or type(v1) ~= "table" or type(v2) ~= "table" then
        return nil
    end
    
    -- Compare major
    if v1.major > v2.major then return 1 end
    if v1.major < v2.major then return -1 end
    
    -- Compare minor
    if v1.minor > v2.minor then return 1 end
    if v1.minor < v2.minor then return -1 end
    
    -- Compare hotfix
    if v1.hotfix > v2.hotfix then return 1 end
    if v1.hotfix < v2.hotfix then return -1 end
    
    return 0  -- Equal
end

-- Function to get local version
local function get_local_version()
    local version_paths = {
        "/version.lua",
        "/disk/hub_files/version.lua",
        drive_path .. "/hub_files/version.lua"
    }
    
    for _, path in ipairs(version_paths) do
        if fs.exists(path) then
            local version_file = fs.open(path, "r")
            if version_file then
                local version_code = version_file.readAll()
                version_file.close()
                local version_func = load(version_code)
                if version_func then
                    local success, version = pcall(version_func)
                    if success and version and type(version) == "table" then
                        return version
                    end
                end
            end
        end
    end
    return nil
end

-- Function to get remote version from GitHub
local function get_remote_version()
    local url = GITHUB_BASE .. "/hub_files/version.lua"
    local response = http.get(url)
    if response then
        local content = response.readAll()
        response.close()
        local version_func = load(content)
        if version_func then
            local success, version = pcall(version_func)
            if success and version and type(version) == "table" then
                return version
            end
        end
    end
    return nil
end

-- Check versions BEFORE updating - this must happen first!
print("Checking for updates...")
local local_version = get_local_version()
local remote_version = get_remote_version()

-- Must have remote version to proceed
if not remote_version then
    print("")
    print("ERROR: Cannot check remote version from GitHub!")
    print("Please check your internet connection and try again.")
    return
end

local local_str = format_version(local_version)
local remote_str = format_version(remote_version)

print("Current version: " .. (local_str or "not found"))
print("Remote version: " .. (remote_str or "unknown"))
print("")

-- If we have local version, check if update is needed
if local_version then
    local comparison = compare_versions(local_version, remote_version)
    if comparison and comparison >= 0 then
        print("Already up-to-date! No update needed.")
        print("(Use 'update force-config' to force update)")
        return
    end
    
    -- Check if this is a major version update
    local is_major_update = false
    if remote_version.major > (local_version.major or 0) then
        is_major_update = true
    end
    
    -- Prompt for major version updates
    if is_major_update then
        print("========================================")
        print("  MAJOR VERSION UPDATE DETECTED")
        print("========================================")
        print("You are updating from " .. local_str .. " to " .. remote_str)
        print("")
        print("WARNING: Major version updates may include:")
        print("  - Breaking changes to configuration files")
        print("  - Changes to file structure or locations")
        print("  - Incompatible changes requiring manual intervention")
        print("  - Changes that may affect turtle compatibility")
        print("")
        print("It is recommended to:")
        print("  - Backup your current configuration")
        print("  - Review the changelog/release notes")
        print("  - Update config files manually if needed")
        print("")
        print("Do you want to proceed with this major update?")
        print("Type 'yes' to continue, anything else to cancel:")
        print("")
        
        -- Read user input
        local user_input = read()
        if user_input ~= "yes" then
            print("")
            print("Update cancelled by user.")
            return
        end
        print("")
        print("Proceeding with major version update...")
        print("")
    end
else
    print("Local version not found - proceeding with fresh install...")
    print("")
end

print("Downloading files from GitHub...")
print("Repository: " .. GITHUB_REPO)
print("")

local updated_count = 0
local skipped_count = 0
local error_count = 0

-- Download and update each file
for _, filepath in ipairs(hub_files) do
    -- Yield to prevent "too long without yielding" error
    os.queueEvent("yield")
    os.pullEvent("yield")
    
    -- Check if we should skip this file
    if not force_config and config_files[filepath] then
        print("  Skipping (config): " .. filepath)
        skipped_count = skipped_count + 1
    else
        local url = GITHUB_BASE .. "/" .. filepath
        local dest_path = drive_path .. "/" .. filepath
        
        print("  Downloading: " .. filepath)
        
        local response = http.get(url)
        if response then
            -- Read content in chunks to avoid timeout
            local content = ""
            while true do
                local chunk = response.read(8192)  -- Read 8KB at a time
                if not chunk then break end
                content = content .. chunk
                -- Yield periodically during large downloads
                if #content % 32768 == 0 then
                    os.queueEvent("yield")
                    os.pullEvent("yield")
                end
            end
            response.close()
            
            -- Create directory if needed
            local dir = string.match(dest_path, "^(.-)[^/\\]*$")
            if dir and dir ~= "" then
                fs.makeDir(dir)
            end
            
            -- Write file (overwrites existing, matching installer behavior)
            local file = fs.open(dest_path, "w")
            if not file then
                print("    ✗ Failed to open file for writing: " .. dest_path)
                error_count = error_count + 1
            else
                file.write(content)
                file.close()
                
                -- Yield after file operations (matching installer)
                os.queueEvent("yield")
                os.pullEvent("yield")
                
                -- Verify file was written and check content
                if fs.exists(dest_path) then
                    -- For monitor.lua, verify key content was downloaded
                    if filepath == "hub_files/monitor.lua" then
                        local verify_file = fs.open(dest_path, "r")
                        if verify_file then
                            local content_check = verify_file.readAll()
                            verify_file.close()
                            if content_check:find("term%.write%('WORLD'") then
                                print("    ✓ Updated successfully (verified)")
                            else
                                print("    ⚠ Updated but content verification failed")
                                print("      (File may be outdated on GitHub)")
                            end
                        end
                    end
                    print("    ✓ Updated successfully")
                    updated_count = updated_count + 1
                else
                    print("    ✗ File write verification failed")
                    error_count = error_count + 1
                end
            end
        else
            print("    ✗ Failed to download from GitHub")
            error_count = error_count + 1
        end
    end
end

print("")
print("========================================")
print("  Update Complete")
print("========================================")
print(string.format("  Updated: %d files", updated_count))
if skipped_count > 0 then
    print(string.format("  Skipped (configs): %d files", skipped_count))
    print("  (Use 'update force-config' to update config files)")
end
if error_count > 0 then
    print(string.format("  Errors: %d files", error_count))
end

-- Update version to match remote version after successful update
if updated_count > 0 and error_count == 0 and remote_version then
    -- Set version to match the remote version we just downloaded
    local new_version = {
        major = remote_version.major or 1,
        minor = remote_version.minor or 0,
        hotfix = remote_version.hotfix or 0
    }
    
    local version_path = drive_path .. "/hub_files/version.lua"
    
    -- Create directory if needed
    local dir = string.match(version_path, "^(.-)[^/\\]*$")
    if dir and dir ~= "" then
        fs.makeDir(dir)
    end
    
    local version_file = fs.open(version_path, "w")
    if version_file then
        version_file.write("-- World Eater Hub Version\n")
        version_file.write("-- This version number matches the version from GitHub\n")
        version_file.write("-- Version format: semantic versioning MAJOR.MINOR.HOTFIX\n")
        version_file.write("-- Returns: {major=1, minor=0, hotfix=0}\n")
        version_file.write("return {\n")
        version_file.write("    major = " .. tostring(new_version.major) .. ",\n")
        version_file.write("    minor = " .. tostring(new_version.minor) .. ",\n")
        version_file.write("    hotfix = " .. tostring(new_version.hotfix) .. "\n")
        version_file.write("}\n")
        version_file.close()
        print(string.format("  Version updated to: %s", format_version(new_version)))
    end
end

print("")
print("Running hub.lua to copy files to root...")
sleep(1)

-- Run hub.lua to copy updated files from disk to root
local hub_lua_path = drive_path .. "/hub.lua"
if fs.exists(hub_lua_path) then
    -- Use os.run to execute hub.lua, which will handle copying files and rebooting
    os.run({}, hub_lua_path)
else
    print("Warning: hub.lua not found, rebooting anyway...")
    print("You may need to manually run: disk/hub.lua")
    sleep(2)
    os.reboot()
end