-- WORLD EATER: Hub Update Script
-- Downloads files from GitHub and updates the hub system
-- Usage: update [dev] [force] [config]
--   dev: If provided, will use latest commits from main branch (dev mode)
--   force: If provided, will update even if versions match
--   config: If provided, will completely replace config files (ignores merge)

local GITHUB_REPO = "Jemsire/CC-World-Eater"
local GITHUB_BRANCH = "main"  -- Fallback if no releases found
local GITHUB_BASE = nil  -- Will be set after getting latest release tag

-- Check for dev, force and config arguments
local dev_mode = false
local force_update = false
local force_config = false
if arg then
    for _, arg_val in ipairs(arg) do
        if arg_val == "dev" then
            dev_mode = true
            print("Dev mode: Using latest commits from main branch")
        elseif arg_val == "force" then
            force_update = true
            print("Force update mode: Will update even if versions match")
        elseif arg_val == "config" then
            force_config = true
            print("Force config mode: Config files will be completely replaced")
        end
    end
end

-- Files to handle specially during update (config merging)
local config_files = {
    ["hub_files/config.lua"] = true,
}

-- Keys where the user's value should completely replace the default (no merging)
-- These are typically list-like or set-like tables where merging doesn't make sense
local replace_keys = {
    dig_disallow = true,  -- User's block list replaces default entirely
    fuelnames = true,     -- User's fuel list replaces default entirely
}

-- Determine drive path first (needed for helper loading)
local drive_path = "/disk"
if not fs.exists(drive_path) then
    error("No disk drive found!")
end

-- Get latest release tag and set GITHUB_BASE accordingly
local latest_tag = nil
if dev_mode then
    -- Dev mode: Use main branch directly (latest commits)
    GITHUB_BASE = "https://raw.githubusercontent.com/" .. GITHUB_REPO .. "/" .. GITHUB_BRANCH
    print("Dev mode: Using latest commits from " .. GITHUB_BRANCH .. " branch")
    print("")
else
    -- Normal mode: Use latest release tag (version locked)
    print("Checking for latest release...")
    latest_tag = github_api.get_latest_release_tag(GITHUB_REPO)
    if latest_tag then
        GITHUB_BASE = "https://raw.githubusercontent.com/" .. GITHUB_REPO .. "/" .. latest_tag
        print("Using latest release: " .. latest_tag)
    else
        -- Fallback to main branch if no releases found
        GITHUB_BASE = "https://raw.githubusercontent.com/" .. GITHUB_REPO .. "/" .. GITHUB_BRANCH
        print("No releases found, using " .. GITHUB_BRANCH .. " branch")
    end
    print("")
end

-- Download file list from GitHub using API
local function get_files()
    local ref_to_use = latest_tag or GITHUB_BRANCH
    local tree = github_api.get_file_tree(GITHUB_REPO, ref_to_use)
    
    if not tree then
        error("Failed to retrieve file list from GitHub API. Please check your internet connection and try again.")
    end

    -- List of paths to get
    local paths_to_get = {
        "hub_files/",
        "turtle_files/",
        "pocket_files/",
        "shared_files/",
    }

    -- List of items to get so we dont download the entire directory
    local items_to_get = {
        "hub.lua",
        "turtle.lua",
        "pocket.lua",
        "install.lua",
    }

    -- Collect files
    local files = {}
    for _, item in ipairs(tree) do
        -- GitHub API returns "blob" for files and "tree" for directories
        if item.type == "blob" and item.path then
            local path = item.path

            -- Check if the path is in the list of paths to get
            for _, path_to_get in ipairs(paths_to_get) do
                if path:find(path_to_get) then
                    table.insert(files, path)
                    break
                end
            end

            -- Check if the item is in the list of items to get
            for _, item_to_get in ipairs(items_to_get) do
                if path:find(item_to_get) then
                    table.insert(files, path)
                end
            end
        end
    end
    return files
end

-- Get hub files dynamically from GitHub
local files = get_files()

-- Check for HTTP API
if not http then
    error("HTTP API not available! Cannot download updates.")
end

print("========================================")
print("  World Eater Update")
print("========================================")

-- Function to get local version
local function get_local_version()
    local version_path = "/version.lua"
    return lua_utils.load_file(version_path)
end

-- Function to get remote version from GitHub
local function get_remote_version()
    local url = GITHUB_BASE .. "/shared_files/version.lua"
    local response = http.get(url)
    if response then
        local content = response.readAll()
        response.close()
        return lua_utils.load_string(content)
    end
    return nil
end

---==[ CONFIG MERGING ]==---

-- Function to update a config file by merging old values into new structure
-- Returns: "updated" if merged, "replaced" if force replaced, "new" if fresh install, nil if error
local function update_config_file(filepath, url, dest_path)
    print("  Updating config: " .. filepath)
    
    -- Download new config from GitHub
    local response = http.get(url)
    if not response then
        print("    ✗ Failed to download new config from GitHub")
        return nil
    end
    
    local new_content = response.readAll()
    response.close()
    
    -- If force_config is set, just write the new config directly
    if force_config then
        if lua_utils.write_file(dest_path, new_content) then
            print("    ✓ Config replaced (force mode)")
            return "replaced"
        else
            print("    ✗ Failed to write config file")
            return nil
        end
    end
    
    local new_config = lua_utils.load_string(new_content)
    if not new_config then
        print("    ✗ Failed to parse new config from GitHub")
        return nil
    end
    
    -- Load existing local config
    local old_config = lua_utils.load_file(dest_path)
    
    local final_config
    local result_type
    if old_config then
        -- Merge old values into new structure
        final_config = lua_utils.merge_tables(new_config, old_config, replace_keys)
        print("    ✓ Merged existing settings into new config structure")
        result_type = "updated"
    else
        -- No existing config, use new config as-is
        final_config = new_config
        print("    ✓ No existing config, using defaults")
        result_type = "new"
    end
    
    -- Build config file content
    local config_content = "-- World Eater Configuration\n"
    config_content = config_content .. "-- Auto-merged during update - your settings have been preserved\n"
    config_content = config_content .. "-- New config options (if any) have been added with default values\n"
    config_content = config_content .. "return " .. lua_utils.serialize_table(final_config) .. "\n"
    
    -- Write merged config
    if lua_utils.write_file(dest_path, config_content) then
        return result_type
    else
        print("    ✗ Failed to write config file")
        return nil
    end
end

---==[ VERSION CHECKING ]==---

-- Check versions BEFORE updating - this must happen first!
print("Checking for updates...")
local local_version = get_local_version()
local remote_version = get_remote_version()

-- Must have remote version to proceed
if not remote_version then
    print("")
    print("ERROR: Cannot check remote version from GitHub!")
    print("Please check your internet connection and try again.")
    return
end

local local_str = lua_utils.format_version(local_version)
local remote_str = lua_utils.format_version(remote_version)

print("Current version: " .. (local_str or "not found"))
if dev_mode then
    print("Remote version (dev): " .. (remote_str or "unknown") .. " (latest commits)")
else
    print("Remote version: " .. (remote_str or "unknown"))
end
print("")

-- In dev mode, skip version comparison and always update
-- Otherwise, check if update is needed
if local_version then
    -- Check version comparison only in non-dev mode
    if not dev_mode then
        local comparison = github_api.compare_versions(local_version, remote_version)
        
        -- Only update if versions are different, unless force is used
        -- comparison: -1 = local < remote (update needed), 0 = equal (skip), 1 = local > remote (skip)
        if comparison and comparison == 0 then
            -- Versions are equal - skip update unless force is used
            if force_update then
                print("Force update mode: Updating despite matching versions...")
                print("")
            else
                print("Already up-to-date! Versions match (" .. local_str .. ").")
                print("(Use 'update force' to force update, 'update dev' for dev mode, or 'update config' to force replace config files)")
                return
            end
        elseif comparison and comparison > 0 then
            -- Local version is newer than remote - skip update unless force is used
            if force_update then
                print("Force update mode: Updating despite local version being newer...")
                print("")
            else
                print("Local version (" .. local_str .. ") is newer than remote (" .. remote_str .. ").")
                print("No update needed. (Use 'update force' to force update anyway)")
                return
            end
        end
        -- If comparison < 0, local is older than remote, so update is needed - continue
        
        -- Check if this is a major version update (skip in dev mode)
        local is_major_update = false
        if remote_version.major > (local_version.major or 0) then
            is_major_update = true
        end
        
        -- Prompt for major version updates (skip in dev mode)
        if is_major_update then
            print("========================================")
            print("  MAJOR VERSION UPDATE DETECTED")
            print("========================================")
            print("You are updating from " .. local_str .. " to " .. remote_str)
            print("")
            print("WARNING: Major version updates may include:")
            print("  - Breaking changes to configuration files")
            print("  - Changes to file structure or locations")
            print("  - Incompatible changes requiring manual intervention")
            print("  - Changes that may affect turtle compatibility")
            print("")
            print("It is recommended to:")
            print("  - Backup your current configuration")
            print("  - Review the changelog/release notes")
            print("  - Update config files manually if needed")
            print("")
            print("Do you want to proceed with this major update?")
            print("Type 'yes' to continue, anything else to cancel:")
            print("")
            
            -- Read user input
            local user_input = read()
            if user_input ~= "yes" then
                print("")
                print("Update cancelled by user.")
                return
            end
            print("")
            print("Proceeding with major version update...")
            print("")
        end
    else
        -- Dev mode: always update
        print("Dev mode: Updating to latest commits from main branch...")
        print("")
    end
else
    print("Local version not found - proceeding with fresh install...")
    print("")
end

print("Downloading files from GitHub...")
print("Repository: " .. GITHUB_REPO)
if dev_mode then
    print("Mode: DEV (latest commits from " .. GITHUB_BRANCH .. " branch)")
else
    print("Mode: RELEASE (version locked to " .. (latest_tag or GITHUB_BRANCH) .. ")")
end
print("")

print("Continuing in 5 seconds...")
sleep(5)

local updated_count = 0
local config_count = 0
local skipped_count = 0
local error_count = 0

-- Download and update each hub file
for _, filepath in ipairs(files) do
    -- Yield to prevent "too long without yielding" error
    os.queueEvent("yield")
    os.pullEvent("yield")
    
    local url = GITHUB_BASE .. "/" .. filepath
    local dest_path = drive_path .. "/" .. filepath
    
    -- Check if this is a config file
    if config_files[filepath] then
        -- Use config merging (preserves user settings while getting new structure)
        local result = update_config_file(filepath, url, dest_path)
        if result then
            config_count = config_count + 1
            updated_count = updated_count + 1
        else
            error_count = error_count + 1
        end
    else
        -- Regular file handling
        print("  Downloading: " .. filepath)
        
        local response = http.get(url)
        if response then
            -- Read content in chunks to avoid timeout
            local content = ""
            while true do
                local chunk = response.read(8192)  -- Read 8KB at a time
                if not chunk then break end
                content = content .. chunk
                -- Yield periodically during large downloads
                if #content % 32768 == 0 then
                    os.queueEvent("yield")
                    os.pullEvent("yield")
                end
            end
            response.close()
            
            -- Write file using lua_utils
            if lua_utils.write_file(dest_path, content) then
                -- Verify file was written and check content
                if lua_utils.file_exists(dest_path) then
                    -- For monitor.lua, verify key content was downloaded
                    if filepath == "hub_files/monitor.lua" then
                        local content_check = lua_utils.read_file(dest_path)
                        if content_check and content_check:find("term%.write%('WORLD'") then
                            print("    ✓ Updated successfully (verified)")
                        else
                            print("    ⚠ Updated but content verification failed")
                            print("      (File may be outdated on GitHub)")
                        end
                    else
                        print("    ✓ Updated successfully")
                    end
                    updated_count = updated_count + 1
                else
                    print("    ✗ File write verification failed")
                    error_count = error_count + 1
                end
            else
                print("    ✗ Failed to write file: " .. dest_path)
                error_count = error_count + 1
            end
        else
            print("    ✗ Failed to download from GitHub")
            error_count = error_count + 1
        end
    end
end

print("")
print("========================================")
print("  Update Complete")
print("========================================")
print(string.format("  Updated: %d files", updated_count))
if config_count > 0 then
    print(string.format("  Configs merged: %d files", config_count))
    print("  (User settings preserved, new options added)")
end
if skipped_count > 0 then
    print(string.format("  Skipped: %d files", skipped_count))
end
if error_count > 0 then
    print(string.format("  Errors: %d files", error_count))
end

-- Update version to match remote version after successful update
if updated_count > 0 and error_count == 0 and remote_version then
    -- Set version to match the remote version we just downloaded
    local new_version = {
        major = remote_version.major or 1,
        minor = remote_version.minor or 0,
        hotfix = remote_version.hotfix or 0
    }
    
    -- Add DEV suffix if updating in dev mode, otherwise ensure it's removed
    if dev_mode then
        new_version.dev_suffix = "-DEV"
        new_version.dev = true
    else
        new_version.dev_suffix = nil
        new_version.dev = false
    end
    
    local version_path = drive_path .. "/shared_files/version.lua"
    
    -- Build version file content
    local version_content = "-- World Eater Version\n"
    version_content = version_content .. "-- This version number matches the version from GitHub\n"
    version_content = version_content .. "-- Version format: semantic versioning MAJOR.MINOR.HOTFIX\n"
    if dev_mode then
        version_content = version_content .. "-- DEV MODE: This version has -DEV suffix\n"
    end
    version_content = version_content .. "-- Returns: {major=1, minor=0, hotfix=0, dev_suffix=\"-DEV\"}\n"
    version_content = version_content .. "return {\n"
    version_content = version_content .. "    major = " .. tostring(new_version.major) .. ",\n"
    version_content = version_content .. "    minor = " .. tostring(new_version.minor) .. ",\n"
    version_content = version_content .. "    hotfix = " .. tostring(new_version.hotfix) .. ",\n"
    if dev_mode then
        version_content = version_content .. "    dev_suffix = \"-DEV\",\n"
        version_content = version_content .. "    dev = true\n"
    else
        version_content = version_content .. "    dev_suffix = nil,\n"
        version_content = version_content .. "    dev = false\n"
    end
    version_content = version_content .. "}\n"
    
    if lua_utils.write_file(version_path, version_content) then
        local version_str = lua_utils.format_version(new_version)
        if dev_mode then
            print(string.format("  Version updated to: %s (dev mode)", version_str))
        else
            print(string.format("  Version updated to: %s", version_str))
        end
    end
end

print("")
print("Running hub.lua to copy files to root...")
sleep(1)

-- Run hub.lua to copy updated files from disk to root
local hub_lua_path = drive_path .. "/hub.lua"
if lua_utils.file_exists(hub_lua_path) then
    -- Use os.run to execute hub.lua, which will handle copying files and rebooting
    os.run({}, hub_lua_path)
else
    print("Warning: hub.lua not found, rebooting anyway...")
    print("You may need to manually run: disk/hub.lua")
    sleep(2)
    os.reboot()
end